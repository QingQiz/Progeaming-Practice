// ============================================================================
// Description: 最大加权矩形
// URL: https://www.luogu.org/problemnew/show/P1719
// Author: Sofee < _s@mail.nwpu.edu.cn >
// ============================================================================
#include <iostream>

using namespace std;

int dt[121][121];
int sm[121][121];
int dp[121], ans = -2147483647;

int main() {
    int n; cin >> n;
    for (int i = 1; i <= n; ++i)
        for (int j = 1; j <= n; ++j)
            cin >> dt[i][j],
                sm[i][j] = sm[i][j - 1] + dt[i][j];
    for (int i = 1; i <= n; ++i) {
        for (int j = i; j <= n; ++j) {
            for (int k = 1; k <= n; ++k) {
                dp[k] = max(dp[k - 1] + sm[k][j] - sm[k][i - 1],\
                            sm[k][j] - sm[k][i - 1]);
                ans = max(ans, dp[k]);
            }
        }
    }
    cout << ans << endl;
}
// ============================================================================
// Keys: sm代表每一行的前缀和，枚举矩形的长，以这个长的和最为树值计算最大连续和
// ------------
// ---++++-----   <-
// ---++++-----   <-
// ---++++-----   <-
// ------------
// 即枚举选取的+(4)的起始位置，向下计算最大连续子序列和
// ============================================================================
